<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>VAULT RUN</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; background: #000; overflow: hidden; }
  canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; cursor: none; }

  #wrap {
    position: fixed; inset: 0;
    display: grid; place-items: center;
    background: #000;
  }
  /* Ambient room glow */
  #wrap::before {
    content: ''; position: fixed; inset: 0; pointer-events: none;
    background: radial-gradient(ellipse at 50% 45%, rgba(0,180,255,0.08) 0%, transparent 60%);
    z-index: 0;
  }

  /* ── CRT container ── */
  #crt-container {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    box-shadow:
      0 0 60px  rgba(0,200,255,0.20),
      0 0 120px rgba(120,0,255,0.08),
      inset 0 0 1px rgba(200,220,255,0.12);
    animation: crt-on 0.8s ease-out;
  }
  /* Glass reflection */
  #crt-container::before {
    content: ''; position: absolute; inset: -2px; border-radius: 18px;
    background: linear-gradient(135deg, rgba(255,255,255,0.05), transparent 40%, transparent 60%, rgba(255,255,255,0.02));
    z-index: 14; pointer-events: none;
  }

  /* Phosphor bloom */
  #phosphor-canvas {
    position: absolute; inset: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 9;
    opacity: 0.16; filter: blur(3px);
  }

  /* Scanlines */
  #scanlines {
    position: absolute; inset: 0; pointer-events: none; z-index: 10;
    background: repeating-linear-gradient(
      0deg,
      rgba(0,0,0,0)    0px, rgba(0,0,0,0)    1px,
      rgba(0,0,0,0.35) 1px, rgba(0,0,0,0.35) 2px
    );
    mix-blend-mode: multiply;
  }

  /* RGB sub-pixel */
  #rgb-grid {
    position: absolute; inset: 0; pointer-events: none; z-index: 11; opacity: 0.03;
    background: repeating-linear-gradient(
      90deg,
      rgba(255,0,0,1) 0px, rgba(255,0,0,1) 1px,
      rgba(0,255,0,1) 1px, rgba(0,255,0,1) 2px,
      rgba(0,0,255,1) 2px, rgba(0,0,255,1) 3px
    );
    background-size: 3px 1px;
  }

  /* Vignette */
  #crt-glow {
    position: absolute; inset: 0; pointer-events: none; z-index: 12;
    box-shadow:
      inset 0 0  80px rgba(0,0,0,0.80),
      inset 0 0 160px rgba(0,0,0,0.50),
      inset 0 0 280px rgba(0,0,0,0.30);
    border-radius: 16px;
  }

  /* Flicker */
  #flicker {
    position: absolute; inset: 0; pointer-events: none; z-index: 13;
    opacity: 0; background: rgba(160,200,255,0.04);
    animation: crt-flicker 0.15s infinite;
  }
  @keyframes crt-flicker {
    0%  { opacity: 0 }   5%  { opacity: 1 }
    10% { opacity: 0 }   15% { opacity: 0.5 }
    20% { opacity: 0 }   100%{ opacity: 0 }
  }

  /* High-res text overlay – rendered at display resolution so text stays sharp */
  #text-canvas {
    position: absolute; inset: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 15;
    image-rendering: auto;
  }

  /* Turn-on animation */
  @keyframes crt-on {
    0%  { filter: brightness(30) saturate(0); transform: scaleY(0.005) scaleX(0.8); }
    40% { filter: brightness(5)  saturate(0.5); transform: scaleY(0.9)  scaleX(1);  }
    70% { filter: brightness(1.5) saturate(1);  transform: scaleY(1.02) scaleX(1);  }
    100%{ filter: brightness(1)  saturate(1);   transform: scaleY(1)   scaleX(1);   }
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="crt-container">
    <canvas id="game"></canvas>
    <canvas id="phosphor-canvas"></canvas>
    <div id="scanlines"></div>
    <div id="rgb-grid"></div>
    <div id="crt-glow"></div>
    <div id="flicker"></div>
    <canvas id="text-canvas"></canvas>
  </div>
</div>
<script>
'use strict';

// ─────────────────────────────────────────────────────────────
// CONSTANTS
// ─────────────────────────────────────────────────────────────
const GW = 320, GH = 180;     // internal game resolution
const TS = 16;                 // tile size in pixels
const CHUNK_W = 20;            // tiles per chunk (wide)
const CHUNK_H = 12;            // tiles per chunk (tall)

const GRAVITY  = 0.34;
const TERM_VEL = 8.5;

const PW = 10, PH = 14;        // player pixel size
const P_SPEED       = 1.7;
const P_JUMP        = -5.6;
const P_DASH_SPEED  = 6.5;
const DASH_FRAMES   = 10;
const DASH_COOLDOWN = 50;
const ATK_FRAMES    = 14;
const ATK_COOLDOWN  = 22;
const ATK_RANGE     = 24;

const POWERUPS = {
  double_jump: { label: 'EXTRA JUMP',  desc: '+1 mid-air jump (triple jump)',     color: '#00e5ff' },
  blade_storm: { label: 'BLADESTORM',   desc: 'Attacks fire a projectile',       color: '#ff44ff' },
  iron_skin:   { label: 'IRON SKIN',    desc: '+1 max HP  ·  restore 1 HP',      color: '#aaaaee' },
  speed_demon: { label: 'SPEED DEMON',  desc: '1.32× movement speed',            color: '#ffee00' },
  phase_dash:  { label: 'PHASE DASH',   desc: 'Faster dash, immune to bullets',  color: '#cc44ff' },
  lifesteal:   { label: 'LIFESTEAL',    desc: 'Recover HP on kills',             color: '#ff4466' },
};
const POWERUP_KEYS = Object.keys(POWERUPS);

// Shop items (meta-progression)
const SHOP_ITEMS = [
  { key: 'armorLevel',   label: 'REINFORCED SUIT',  desc: '+1 starting HP  (max +3)',   cost: 10, maxOwn: 3, color: '#ff4466' },
  { key: 'speedLevel',   label: 'OVERCLOCKED LEGS', desc: 'Start every run with SPEED DEMON', cost: 15, maxOwn: 1, color: '#ffee00' },
  { key: 'arsenalLevel', label: 'WEAPONS CACHE',    desc: 'Start every run with BLADESTORM', cost: 15, maxOwn: 1, color: '#ff44ff' },
];

// 80s CRT arcade palette
const C = {
  bg:        '#08081c',   // deep navy-black
  dim:       '#10103a',   // faint grid lines
  tile:      '#1a2a6a',   // dark-blue bricks
  tileHi:    '#3a5acc',   // bright blue highlight
  tileLo:    '#0d1240',   // shadow edge
  tileInner: '#13194e',   // inner recess
  platform:  '#006e6e',   // teal platform
  platEdge:  '#00dddd',   // bright teal edge
  spike:     '#ff1a00',   // hot red
  spikeGlow: '#ff5500',   // orange-red glow
  player:    '#00e5ff',   // cyan player
  playerDim: '#004466',   // dark cyan
  playerBody:'#001e33',   // very dark body
  visor:     '#ff6ec7',   // hot-pink visor
  enemy:     '#ff6600',   // vivid orange
  enemyDim:  '#7a2e00',   // dark orange
  boss:      '#ffcc00',   // gold
  bossDim:   '#664400',   // dark gold
  coin:      '#ffd700',   // gold coin
  coinGlow:  '#ffbb00',
  powerup:   '#ff44ff',   // magenta
  exit:      '#00ffcc',   // teal exit
  exitGlow:  '#00ffcc',
  hurt:      '#ff2244',   // red hurt flash
  text:      '#00e5ff',   // cyan UI text
  textDim:   '#005577',   // dim cyan
  textBright:'#ccffff',   // near-white cyan
  uiBg:      '#040412',   // dark panel
  uiBorder:  '#1a2860',   // blue border
};

// ─────────────────────────────────────────────────────────────
// UTILS
// ─────────────────────────────────────────────────────────────
const rng = {
  _s: Date.now() | 1,
  next() {
    this._s ^= this._s << 13;
    this._s ^= this._s >> 17;
    this._s ^= this._s << 5;
    return (this._s >>> 0) / 4294967296;
  },
  int(lo, hi) { return lo + Math.floor(this.next() * (hi - lo + 1)); },
  pick(a)     { return a[this.int(0, a.length - 1)]; },
  shuffle(a)  {
    const r = [...a];
    for (let i = r.length - 1; i > 0; i--) {
      const j = this.int(0, i);
      [r[i], r[j]] = [r[j], r[i]];
    }
    return r;
  },
};

const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp  = (a, b, t)   => a + (b - a) * t;

function overlaps(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

// ─────────────────────────────────────────────────────────────
// INPUT
// ─────────────────────────────────────────────────────────────
const keys    = {};
const pressed = {};

window.addEventListener('keydown', e => {
  if (!keys[e.code]) pressed[e.code] = true;
  keys[e.code] = true;
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))
    e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

function down(...codes) { return codes.some(c => keys[c]); }
function just(...codes) { return codes.some(c => pressed[c]); }
function clearInput()   { for (const k in pressed) delete pressed[k]; }

// ─────────────────────────────────────────────────────────────
// CANVAS SETUP
// ─────────────────────────────────────────────────────────────
const gameCanvas = document.getElementById('game');
gameCanvas.width  = GW;
gameCanvas.height = GH;
const ctx = gameCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const phosphorCanvas = document.getElementById('phosphor-canvas');
phosphorCanvas.width  = GW;
phosphorCanvas.height = GH;
const phosphorCtx = phosphorCanvas.getContext('2d');
phosphorCtx.imageSmoothingEnabled = false;

// High-resolution text overlay canvas – sized to display pixels so text renders crisply
const textCanvas = document.getElementById('text-canvas');
let textCtx = textCanvas.getContext('2d');
let displayScale = 1;

const crtContainer = document.getElementById('crt-container');
function resizeCRT() {
  const aspect = GW / GH;
  let cw = window.innerWidth  * 0.98;
  let ch = window.innerHeight * 0.96;
  if (cw / ch > aspect) cw = ch * aspect; else ch = cw / aspect;
  cw = Math.floor(cw); ch = Math.floor(ch);
  crtContainer.style.width  = cw + 'px';
  crtContainer.style.height = ch + 'px';
  gameCanvas.style.width    = cw + 'px';
  gameCanvas.style.height   = ch + 'px';
  // Keep text canvas at true display resolution so 1 canvas px = 1 screen px
  textCanvas.width  = cw;
  textCanvas.height = ch;
  textCtx = textCanvas.getContext('2d');
  displayScale = cw / GW;
}
window.addEventListener('resize', resizeCRT);
resizeCRT();

// ─────────────────────────────────────────────────────────────
// DRAW HELPERS  (render to low-res gameCanvas)
// ─────────────────────────────────────────────────────────────
function fillRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
}

function glowRect(x, y, w, h, color, glowColor, blur = 6) {
  ctx.save();
  ctx.shadowColor = glowColor ?? color;
  ctx.shadowBlur  = blur;
  ctx.fillStyle   = color;
  ctx.fillRect(x, y, w, h);
  ctx.restore();
}

function text(str, x, y, {
  size  = 6,
  color = C.text,
  align = 'left',
  glow  = null,
  blur  = 4,
} = {}) {
  // Draw on the high-res overlay so text is crisp at any display size
  const s = displayScale;
  textCtx.save();
  textCtx.font         = `${Math.round(size * s)}px monospace`;
  textCtx.textAlign    = align;
  textCtx.textBaseline = 'top';
  if (glow) { textCtx.shadowColor = glow; textCtx.shadowBlur = blur * s; }
  textCtx.fillStyle = color;
  textCtx.fillText(str, Math.round(x * s), Math.round(y * s));
  textCtx.restore();
}

// ─────────────────────────────────────────────────────────────
// META PERSISTENCE
// ─────────────────────────────────────────────────────────────
function loadMeta() {
  try {
    const raw = localStorage.getItem('vaultrun_meta');
    if (raw) return JSON.parse(raw);
  } catch (_) {}
  return { coins: 0, armorLevel: 0, speedLevel: 0, arsenalLevel: 0 };
}
function saveMeta(m) {
  try { localStorage.setItem('vaultrun_meta', JSON.stringify(m)); } catch (_) {}
}

// ─────────────────────────────────────────────────────────────
// CHUNK TEMPLATES  (20 × 12 tiles each)
// 0=empty 1=solid 2=one-way platform 3=spike
// ─────────────────────────────────────────────────────────────
function makeChunk(rows12) {
  // rows12: exactly 12 strings of exactly 20 chars
  // '.' empty  'X' solid  'P' platform  'S' spike
  const map = { '.': 0, 'X': 1, 'P': 2, 'S': 3 };
  const a   = new Uint8Array(CHUNK_W * CHUNK_H);
  rows12.forEach((row, r) => {
    for (let c = 0; c < CHUNK_W; c++)
      a[r * CHUNK_W + c] = map[row[c] ?? '.'] ?? 0;
  });
  return a;
}

const START_CHUNK = makeChunk([
  '....................', // 0
  '....................', // 1
  '....................', // 2
  '....................', // 3
  '....................', // 4
  '....................', // 5
  '....................', // 6
  '....................', // 7
  'XXXXXXX.....PP..PP..', // 8 ← raised spawn pad (cols 0-6); tier-1 at 12-13 & 17-18
  'XXXXXXX.............', // 9
  'XXXXXXX.............', // 10
  'XXXXXXXXXXXXXXXXXXXX', // 11
]);

const EXIT_CHUNK = makeChunk([
  '....................', // 0
  '....................', // 1
  '...............PPPPP', // 2  ← exit platform (cols 15-19); portal at col 16
  '....................', // 3
  '....................', // 4
  '............PPPP....', // 5  ← step 2 (cols 12-15); 48 px above step 1 = double jump
  '....................', // 6
  '....................', // 7
  '........PPPP........', // 8  ← step 1 (cols 8-11); 48 px above floor = double jump
  '....................', // 9
  '....................', // 10
  'XXXXXXXXXXXXXXXXXXXX', // 11 ← floor (player enters here)
]);

const CHUNKS = [
  // 0: Pit — tier-1 flanking platforms + stepping stone over gap + tier-2 above
  makeChunk([
    '....................',
    '....................',
    '....................',
    '....................',
    '....................',
    '....PPPP.......PPPP.', // tier-2 at cols 4-7 & 15-18 (reachable from stone)
    '....................',
    '....................',
    '..PP.....PP.....PP..', // tier-1: cols 2-3, 9-10 (over pit), 16-17
    '....................',
    '....................',
    'XXXXXXXX....XXXXXXXX', // pit at cols 8-11
  ]),
  // 1: Multi-level platforms — tier-1 base leads to tier-2 above
  makeChunk([
    '....................',
    '....................',
    '....................',
    '....................',
    '.....PPPPPP.........', // tier-2 at cols 5-10
    '....................',
    '.............PPP....', // tier-2 at cols 13-15
    '....................',
    'PPP.....PPP.....PPP.', // tier-1 at cols 0-2, 8-10, 16-18
    '....................',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 2: Raised terrain — tier-1 flanking platforms let player scale the solid section
  makeChunk([
    '....................',
    '....................',
    '....................',
    '....................',
    '........XXXXXXX.....', // solid raised hill
    '......XXXXXXXXX.....',
    '....XXXXXXXXX.......',
    '....................',
    '..PP.........PP.....', // tier-1 at cols 2-3 & 13-14
    '....................',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 3: Pit — wide tier-1 coverage + stepping stone over gap
  makeChunk([
    '....................',
    '....................',
    '....................',
    '....PPP.............', // tier-2 left (cols 4-6)
    '....................',
    '.............PPP....', // tier-2 right (cols 13-15)
    '....................',
    '....................',
    'PP.......PP.......PP', // tier-1: cols 0-1, 9-10 (over pit), 18-19
    '....................',
    '....................',
    'XXXXXXXX....XXXXXXXX', // pit at cols 8-11
  ]),
  // 4: Spike gauntlet — tier-1 in safe zones let player hop over the spikes
  makeChunk([
    '....................',
    '....................',
    '.....PPP....PPP.....', // tier-3 (cols 5-7 & 12-14)
    '....................',
    '....................',
    '..PPP...........PPP.', // tier-2 (cols 2-4 & 15-17)
    '....................',
    '....................',
    '......PP......PP....', // tier-1 in safe zones (cols 6-7 & 14-15)
    '.SSS.......SSSS.....', // spikes (cols 1-3 & 11-14)
    '.SSS.......SSSS.....',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 5: Ceiling room — tier-1 base to reach the hanging platforms above
  makeChunk([
    'XXXXXXXXXXXXXXXXXXXX', // ceiling
    '....................',
    '....................',
    '......PPPP..........', // tier-3 (cols 6-9)
    '....................',
    '....................',
    '.............PPPP...', // tier-2 (cols 13-16)
    '..PPPP..............', // tier-2 (cols 2-5)
    '.......PP......PP...', // tier-1 at cols 7-8 & 15-16
    '....................',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 6: Two tall pillars to jump over — tier-1 at cols 1-2, 11-12, 18-19 (safe from pillar overhang)
  makeChunk([
    '....................',
    '....................',
    '....................',
    '.......XXXX.........',
    '.......XXXX...XXXXX.',
    '.......XXXX...XXXXX.',
    '.......XXXX...XXXXX.',
    '.......XXXX...XXXXX.',
    '.PP.......PP.....PP.', // tier-1: cols 1-2, 11-12, 18-19
    '....................',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 7: Staircase platforms rising right — tier-1 entry at cols 0-2 to bootstrap the ascent
  makeChunk([
    '....................',
    '....................',
    '....................',
    '................PP..',
    '............PP......',
    '........PP..........',
    '....PP..............',
    '....................',
    'PPP.................', // tier-1: cols 0-2 (stepping stone to reach row-6 platform)
    '....................',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
  // 8: Wide pit — entry/exit pads + two over-pit stepping stones + tier-2 bridge
  makeChunk([
    '....................',
    '....................',
    '....................',
    '....................',
    '....................',
    '.........PPPP.......', // tier-2 bridge (cols 9-12, y=80)
    '....................',
    '....................',
    'PP.....PP..PP.....PP', // tier-1: entry (0-1), stones (7-8, 11-12), exit (18-19)
    '....................',
    '....................',
    'XXXXXXX.....XXXXXXXX', // pit at cols 7-11 (5 tiles wide)
  ]),
  // 9: Mixed — solid ledge, spikes on ground, tier-1 platforms outside spike zones
  makeChunk([
    '....................',
    '....................',
    '.......XXXX.........',
    '.......XXXX.........',
    '.......XXXX.........',
    '....................',
    '....................',
    '....................',
    '......PP.....PP.....', // tier-1: cols 6-7 & 13-14 (clear of spike zones 0-4 & 16-19)
    'SSSSS...........SSSS',
    '....................',
    'XXXXXXXXXXXXXXXXXXXX',
  ]),
];

// ─────────────────────────────────────────────────────────────
// LEVEL GENERATOR
// ─────────────────────────────────────────────────────────────
class Level {
  constructor(floor, isBoss) {
    this.floor    = floor;
    this.isBoss   = isBoss;
    this.tileW    = 0;
    this.tileH    = CHUNK_H;
    this._tiles   = null;
    this.coins    = [];
    this.enemies  = [];
    this.boss     = null; // reference to boss enemy (boss floors only)
    this.exitX    = 0;    // pixel coords of portal
    this.exitY    = 0;
    this.exitOpen = false;
    this._generate();
  }

  _generate() {
    const numMid = this.isBoss ? 2 : clamp(4 + this.floor, 5, 10);
    const pool   = rng.shuffle([...Array(CHUNKS.length).keys()]);
    const segs   = [START_CHUNK];
    for (let i = 0; i < numMid; i++) segs.push(CHUNKS[pool[i % pool.length]]);
    segs.push(EXIT_CHUNK);

    this.tileW  = segs.length * CHUNK_W;
    this._tiles = new Uint8Array(this.tileW * this.tileH);

    segs.forEach((chunk, si) => {
      for (let r = 0; r < CHUNK_H; r++)
        for (let c = 0; c < CHUNK_W; c++)
          this._tiles[r * this.tileW + si * CHUNK_W + c] = chunk[r * CHUNK_W + c];
    });

    // Scatter coins in mid-chunks (avoid first and last)
    for (let si = 1; si < segs.length - 1; si++) {
      const n = rng.int(2, 5);
      for (let k = 0; k < n; k++) {
        const tc = si * CHUNK_W + rng.int(2, CHUNK_W - 3);
        for (let tr = CHUNK_H - 2; tr >= 1; tr--) {
          const here  = this.getTile(tc, tr);
          const below = this.getTile(tc, tr + 1);
          if (here === 0 && (below === 1 || below === 2)) {
            this.coins.push({ x: tc * TS + 4, y: tr * TS + 2, taken: false });
            break;
          }
        }
      }
    }

    // Exit portal: on the elevated staircase platform in the exit chunk
    this.exitX    = (segs.length - 1) * CHUNK_W * TS + TS * 16; // col 16 of exit chunk
    this.exitY    = 2 * TS;                                       // row 2 surface (y=32)
    this.exitOpen = false;

    // Spawn enemies (regular floors) or boss (boss floor)
    if (this.isBoss) {
      this.spawnBoss();
    } else {
      this.spawnEnemies(this.floor);
      if (this.enemies.length === 0) this.exitOpen = true;
    }
  }

  getTile(col, row) {
    if (col < 0 || col >= this.tileW || row < 0 || row >= this.tileH) return 0;
    return this._tiles[row * this.tileW + col];
  }
  isSolid(c, r)    { return this.getTile(c, r) === 1; }
  isPlatform(c, r) { return this.getTile(c, r) === 2; }
  isSpike(c, r)    { return this.getTile(c, r) === 3; }
  get pxW() { return this.tileW * TS; }
  get pxH() { return this.tileH * TS; }

  // ── Boss spawning ───────────────────────────────────────────
  spawnBoss() {
    const bw = 24, bh = 28;
    const midX = Math.floor(this.tileW / 2) * TS - bw / 2;
    const groundY = (CHUNK_H - 1) * TS - bh;
    const b = newBoss(midX, groundY);
    this.enemies.push(b);
    this.boss = b;
  }

  // ── Enemy spawning (called after tile layout) ──────────────
  spawnEnemies(floor) {
    // Unlock harder types gradually: walkers only early, jumpers mid, shooters late
    const ETYPES = floor < 3  ? ['walker'] :
                   floor < 6  ? ['walker', 'walker', 'jumper'] :
                                 ['walker', 'shooter', 'jumper'];
    // segs.length = tileW / CHUNK_W
    const numSegs = this.tileW / CHUNK_W;
    for (let si = 1; si < numSegs - 1; si++) {
      const maxE = clamp(floor, 1, 3);
      const numE = rng.int(1, maxE);
      for (let k = 0; k < numE; k++) {
        const type = rng.pick(ETYPES);
        const eh   = type === 'shooter' ? 12 : 10;
        const ew   = type === 'shooter' ? 12 : 10;
        // Random column within this chunk (avoid edges)
        const tc = si * CHUNK_W + rng.int(3, CHUNK_W - 4);
        // Find highest empty row above solid ground
        for (let tr = CHUNK_H - 2; tr >= 2; tr--) {
          const here  = this.getTile(tc, tr);
          const below = this.getTile(tc, tr + 1);
          if (here === 0 && (below === 1 || below === 2)) {
            // Enemy bottom rests on top of row tr+1
            this.enemies.push(newEnemy(type, tc * TS, (tr + 1) * TS - eh, ew, eh, floor));
            break;
          }
        }
      }
    }
  }
}

// ─────────────────────────────────────────────────────────────
// PHYSICS
// ─────────────────────────────────────────────────────────────
function moveAndCollide(ent, level, solid = true) {
  // ── X ──────────────────────────────────────
  ent.x += ent.vx;

  if (solid) {
    const tT = Math.floor(ent.y / TS);
    const tB = Math.floor((ent.y + ent.h - 1) / TS);
    if (ent.vx > 0) {
      const tc = Math.floor((ent.x + ent.w - 1) / TS);
      for (let r = tT; r <= tB; r++) {
        if (level.isSolid(tc, r)) { ent.x = tc * TS - ent.w; ent.vx = 0; break; }
      }
    } else if (ent.vx < 0) {
      const tc = Math.floor(ent.x / TS);
      for (let r = tT; r <= tB; r++) {
        if (level.isSolid(tc, r)) { ent.x = (tc + 1) * TS; ent.vx = 0; break; }
      }
    }
    // Level bounds
    ent.x = clamp(ent.x, 0, level.pxW - ent.w);
  }

  // ── Y ──────────────────────────────────────
  ent.vy       = Math.min(ent.vy + GRAVITY, TERM_VEL);
  ent.y       += ent.vy;
  ent.onGround = false;

  if (solid) {
    const tL = Math.floor(ent.x / TS);
    const tR = Math.floor((ent.x + ent.w - 1) / TS);
    if (ent.vy >= 0) {
      const tr = Math.floor((ent.y + ent.h - 1) / TS);
      for (let c = tL; c <= tR; c++) {
        if (level.isSolid(c, tr)) {
          ent.y = tr * TS - ent.h;
          ent.vy = 0; ent.onGround = true; break;
        }
        // One-way: only land if coming from above
        if (level.isPlatform(c, tr) && (ent.y - ent.vy + ent.h - 1) <= tr * TS) {
          ent.y = tr * TS - ent.h;
          ent.vy = 0; ent.onGround = true; break;
        }
      }
    } else {
      const tr = Math.floor(ent.y / TS);
      for (let c = tL; c <= tR; c++) {
        if (level.isSolid(c, tr)) { ent.y = (tr + 1) * TS; ent.vy = 0; break; }
      }
    }
    // Pit kill zone check is done outside (in game update)
  }
}

// ─────────────────────────────────────────────────────────────
// PARTICLE SYSTEM
// ─────────────────────────────────────────────────────────────
let particles = [];

function spawnParticles(x, y, color, n, opts = {}) {
  const { vxRange = 2.5, vyRange = 2.5, vyBias = -1, life = 18, size = 2 } = opts;
  for (let i = 0; i < n; i++) {
    particles.push({
      x, y,
      vx: (rng.next() - 0.5) * vxRange * 2,
      vy: vyBias + (rng.next() - 0.5) * vyRange * 2,
      color,
      life, maxLife: life,
      size,
    });
  }
}

function updateParticles() {
  particles = particles.filter(p => {
    p.x  += p.vx;
    p.y  += p.vy;
    p.vy += 0.12;
    p.life--;
    return p.life > 0;
  });
}

function drawParticles(camX, camY) {
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = p.color;
    ctx.shadowBlur  = 3;
    ctx.fillStyle   = p.color;
    ctx.fillRect(p.x - camX - p.size / 2, p.y - camY - p.size / 2, p.size, p.size);
    ctx.restore();
  }
}

// ─────────────────────────────────────────────────────────────
// PLAYER
// ─────────────────────────────────────────────────────────────
function newPlayer(x, y, meta) {
  const hp = 4 + (meta.armorLevel | 0);
  return {
    x, y, vx: 0, vy: 0,
    w: PW, h: PH,
    hp, maxHp: hp,
    coins: 0,
    dir: 1,          // 1=right, -1=left
    onGround: false,
    jumpExtra: 0,    // remaining mid-air jumps
    maxJumpExtra: 1, // resets to this on landing (powerup raises it to 2)
    dashTimer:    0,
    dashCooldown: 0,
    atkTimer:     0,
    atkCooldown:  0,
    hurtTimer:    0,
    hurtCooldown: 0,
    frame:   0,
    state:  'idle',
    powerups: [],
    hasDoubleJump: true,  // base mechanic — always available
    hasBladestorm: (meta.arsenalLevel | 0) > 0,
    hasSpeedDemon: (meta.speedLevel   | 0) > 0,
    hasPhaseDash:  false,
    hasLifesteal:  false,
    dead: false,
  };
}

function applyPowerup(p, key) {
  if (!p.powerups.includes(key)) p.powerups.push(key);
  if (key === 'double_jump') p.maxJumpExtra = 2; // triple jump: 2 mid-air jumps
  if (key === 'blade_storm') p.hasBladestorm = true;
  if (key === 'iron_skin')   { p.maxHp++; p.hp = Math.min(p.hp + 1, p.maxHp); }
  if (key === 'speed_demon') p.hasSpeedDemon = true;
  if (key === 'phase_dash')  p.hasPhaseDash  = true;
  if (key === 'lifesteal')   p.hasLifesteal  = true;
}

function updatePlayer(p, level, projectiles) {
  if (p.dead) return;
  p.frame++;

  const isDashing = p.dashTimer > 0;

  // ── Timers ──
  if (p.dashTimer    > 0) p.dashTimer--;
  if (p.dashCooldown > 0) p.dashCooldown--;
  if (p.atkTimer     > 0) p.atkTimer--;
  if (p.atkCooldown  > 0) p.atkCooldown--;
  if (p.hurtTimer    > 0) p.hurtTimer--;
  if (p.hurtCooldown > 0) p.hurtCooldown--;

  if (isDashing && !p.hasPhaseDash) {
    // Locked forward during dash (no steering)
    p.state = 'dash';
  } else {
    const spd = P_SPEED * (p.hasSpeedDemon ? 1.32 : 1);

    // ── Horizontal ──
    if (down('ArrowLeft',  'KeyA')) { p.vx = -spd; p.dir = -1; }
    else if (down('ArrowRight', 'KeyD')) { p.vx =  spd; p.dir =  1; }
    else p.vx *= 0.72;

    // ── Jump ──
    if (just('ArrowUp', 'KeyW', 'Space')) {
      if (p.onGround) {
        p.vy = P_JUMP;
        spawnParticles(p.x + p.w / 2, p.y + p.h, C.player, 5,
          { vxRange: 1.5, vyRange: 0.8, vyBias: -0.2, life: 12, size: 1.5 });
      } else if (p.jumpExtra > 0) {
        p.vy = P_JUMP * 0.88;
        p.jumpExtra--;
        spawnParticles(p.x + p.w / 2, p.y + p.h / 2, C.visor, 7,
          { vxRange: 2, vyRange: 1.5, vyBias: 0, life: 14, size: 1.5 });
      }
    }
    // Variable jump height cut
    if (!down('ArrowUp', 'KeyW', 'Space') && p.vy < -1.5) p.vy += 0.4;

    // ── Dash ──
    if (just('ShiftLeft', 'ShiftRight') && p.dashCooldown <= 0) {
      p.dashTimer    = DASH_FRAMES;
      p.dashCooldown = p.hasPhaseDash ? Math.floor(DASH_COOLDOWN * 0.55) : DASH_COOLDOWN;
      p.vx = p.dir * P_DASH_SPEED;
      p.vy = -0.3;
      spawnParticles(p.x + p.w / 2, p.y + p.h / 2, C.visor, 9,
        { vxRange: 1.5, vyRange: 1, vyBias: 0, life: 14, size: 2 });
    }

    // ── Shoot (gun) ──
    if (just('KeyZ', 'KeyX', 'KeyJ') && p.atkCooldown <= 0) {
      p.atkTimer    = ATK_FRAMES;
      p.atkCooldown = p.hasBladestorm ? Math.floor(ATK_COOLDOWN * 0.55) : ATK_COOLDOWN;

      // Bullet spawns at barrel tip
      const bx  = p.x + (p.dir > 0 ? p.w + 6 : -10);
      const by  = p.y + 6;
      const spd = 7.0;
      projectiles.push(newProjectile(bx, by, p.dir * spd, 0, 'player', '#ffee44', 7, 2));

      // Bladestorm: triple spread shot
      if (p.hasBladestorm) {
        projectiles.push(newProjectile(bx, by, p.dir * spd * 0.85, -spd * 0.42, 'player', '#ffee44', 6, 2));
        projectiles.push(newProjectile(bx, by, p.dir * spd * 0.85,  spd * 0.42, 'player', '#ffee44', 6, 2));
      }

      // Muzzle flash particles
      spawnParticles(bx, by, '#ffee44', 4,
        { vxRange: 1.0, vyRange: 1.0, vyBias: 0, life: 5, size: 2 });
    }

    // ── State label ──
    if      (p.atkTimer > 0)       p.state = 'attack';
    else if (!p.onGround && p.vy < 0) p.state = 'jump';
    else if (!p.onGround && p.vy > 0) p.state = 'fall';
    else if (Math.abs(p.vx) > 0.4) p.state = 'run';
    else                           p.state = 'idle';
  }

  // Phase-dash: skip tile collision during dash
  const skipTiles = isDashing && p.hasPhaseDash;
  moveAndCollide(p, level, !skipTiles);

  if (p.onGround) p.jumpExtra = p.maxJumpExtra;

  // ── Spike damage ──
  const tL = Math.floor(p.x / TS);
  const tR = Math.floor((p.x + p.w - 1) / TS);
  const tB = Math.floor((p.y + p.h - 1) / TS);
  if (p.hurtCooldown <= 0) {
    for (let c = tL; c <= tR; c++) {
      if (level.isSpike(c, tB)) { hurtPlayer(p, 1); break; }
    }
  }

  // ── Pit kill ──
  if (p.y > level.pxH + 32) { p.hp = 0; p.dead = true; }
}

function hurtPlayer(p, dmg) {
  if (p.hurtCooldown > 0 || p.dead) return;
  p.hp          -= dmg;
  p.hurtTimer    = 22;
  p.hurtCooldown = 60;
  spawnParticles(p.x + p.w / 2, p.y + p.h / 2, C.hurt, 8,
    { vxRange: 3, vyRange: 3, vyBias: -1.5, life: 20, size: 2 });
  if (p.hp <= 0) { p.hp = 0; p.dead = true; }
}

function playerAtkHitbox(p) {
  if (p.atkTimer <= 0) return null;
  const ax = p.dir > 0 ? p.x + p.w - 2 : p.x - ATK_RANGE + 2;
  return { x: ax, y: p.y - 2, w: ATK_RANGE, h: p.h + 4 };
}

// ─────────────────────────────────────────────────────────────
// PROJECTILES
// ─────────────────────────────────────────────────────────────
function newProjectile(x, y, vx, vy, owner, color, w = 4, h = 4) {
  return { x, y, vx, vy, w, h, owner, color, age: 0, dead: false };
}

function updateProjectiles(projs, level) {
  for (const p of projs) {
    if (p.dead) continue;
    p.age++;
    p.x += p.vx;
    p.y += p.vy;
    if (p.age > 200) { p.dead = true; continue; }
    const tc = Math.floor((p.x + 2) / TS);
    const tr = Math.floor((p.y + 2) / TS);
    if (level.isSolid(tc, tr)) p.dead = true;
    if (p.x < 0 || p.x > level.pxW || p.y < 0 || p.y > level.pxH) p.dead = true;
  }
  return projs.filter(p => !p.dead);
}

// ─────────────────────────────────────────────────────────────
// ENEMIES
// ─────────────────────────────────────────────────────────────
function newEnemy(type, x, y, w, h, floor = 1) {
  // All stats scale with floor so early floors feel manageable
  const speed    = Math.min(0.45 + floor * 0.05, 1.1);         // walker patrol speed
  const shootInt = Math.max(170 - floor * 8,  70);              // frames between shots
  const bulletSpd = Math.min(1.6 + floor * 0.1, 3.5);          // projectile speed
  const jVy      = Math.max(-4.0 - floor * 0.1, -5.5);         // jumper launch vy
  const jVx      = Math.min(0.8  + floor * 0.08, 2.4);         // jumper launch vx
  const baseHp   = type === 'shooter' ? 3 : 2;
  const hp       = baseHp + Math.floor(floor / 4);              // +1 HP every 4 floors
  return {
    type, x, y, w, h,
    vx: type === 'walker' ? speed : 0,
    vy: 0,
    hp, maxHp: hp,
    dir: 1,
    onGround: false,
    frame:      0,
    hurtTimer:  0,
    // scaled stats stored per-enemy
    speed, shootInterval: shootInt, bulletSpd, jVy, jVx,
    // type-specific timers (seeded per enemy for desync)
    shootTimer: rng.int(Math.ceil(shootInt * 0.6), shootInt),
    jumpTimer:  rng.int(30, 90),
    dead: false,
  };
}

// Walker: patrols back-and-forth, turns at walls and ledges
function updateWalker(e, level) {
  // Ledge detection (look one step ahead at foot level)
  if (e.onGround) {
    const ahead = e.x + (e.dir > 0 ? e.w + 2 : -3);
    const footR = Math.floor((e.y + e.h) / TS);
    const col   = Math.floor(ahead / TS);
    if (!level.isSolid(col, footR) && !level.isPlatform(col, footR)) {
      e.dir *= -1;
    }
  }
  e.vx = e.dir * e.speed;
  moveAndCollide(e, level);
  // Wall reversal (moveAndCollide zeroed vx on collision)
  if (e.vx === 0) e.dir *= -1;
  // Level-edge reversal
  if (e.x <= 1 && e.dir < 0)              e.dir = 1;
  if (e.x + e.w >= level.pxW - 1 && e.dir > 0) e.dir = -1;
}

// Shooter: stationary, fires toward player when in range
function updateShooter(e, level, player, projectiles) {
  e.vx = 0;
  moveAndCollide(e, level);
  e.dir = player.x > e.x ? 1 : -1;
  e.shootTimer--;
  if (e.shootTimer <= 0) {
    e.shootTimer = rng.int(Math.ceil(e.shootInterval * 0.6), e.shootInterval);
    const dx = player.x + player.w / 2 - (e.x + e.w / 2);
    const dy = player.y + player.h / 2 - (e.y + e.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 220) {
      const spd = e.bulletSpd;
      projectiles.push(newProjectile(
        e.x + e.w / 2, e.y + e.h / 2,
        (dx / dist) * spd, (dy / dist) * spd,
        'enemy', C.enemy,
      ));
    }
  }
}

// Jumper: jumps periodically, drifts toward player in air
function updateJumper(e, level, player) {
  e.jumpTimer--;
  if (e.jumpTimer <= 0 && e.onGround) {
    e.jumpTimer = rng.int(40, 100);
    e.vy = e.jVy;
    const dx = player.x - e.x;
    e.vx = Math.sign(dx) * (e.jVx + rng.next() * e.jVx);
  }
  // Air drift toward player
  if (!e.onGround) {
    const dx = player.x - e.x;
    e.vx = clamp(e.vx + Math.sign(dx) * 0.06, -2.8, 2.8);
  }
  moveAndCollide(e, level);
  e.dir = e.vx >= 0 ? 1 : -1;
  // Level-edge bounce
  if (e.x <= 1 && e.vx < 0)              { e.vx *= -1; e.dir = 1; }
  if (e.x + e.w >= level.pxW - 1 && e.vx > 0) { e.vx *= -1; e.dir = -1; }
}

function updateEnemy(e, level, player, projectiles) {
  if (e.dead) return;
  e.frame++;
  if (e.hurtTimer > 0) e.hurtTimer--;

  if      (e.type === 'walker')  updateWalker(e, level);
  else if (e.type === 'shooter') updateShooter(e, level, player, projectiles);
  else if (e.type === 'jumper')  updateJumper(e, level, player);
}

function hurtEnemy(e, dmg, player) {
  if (e.dead) return false;
  e.hp -= dmg;
  e.hurtTimer = 8;
  spawnParticles(e.x + e.w / 2, e.y + e.h / 2, '#ffe040', 4,
    { vxRange: 2, vyRange: 2, vyBias: -1.5, life: 10, size: 1.5 });
  if (player.hasLifesteal) player.hp = Math.min(player.maxHp, player.hp + 0.5);
  if (e.hp <= 0) { killEnemy(e); return true; }
  return false;
}

function killEnemy(e) {
  e.dead = true;
  const isBossType = e.type === 'boss';
  const col = e.type === 'jumper' ? '#cc00ff' : isBossType ? C.boss : C.enemy;
  const n   = isBossType ? 30 : 12;
  spawnParticles(e.x + e.w / 2, e.y + e.h / 2, col, n,
    { vxRange: isBossType ? 5 : 3.5, vyRange: isBossType ? 5 : 3.5,
      vyBias: isBossType ? -3 : -2, life: isBossType ? 45 : 28, size: isBossType ? 3 : 2 });
  if (isBossType) {
    // Extra secondary burst
    spawnParticles(e.x + e.w / 2, e.y + e.h / 2, '#ffffff', 12,
      { vxRange: 4, vyRange: 4, vyBias: -2.5, life: 30, size: 2 });
  }
}

// ─────────────────────────────────────────────────────────────
// BOSS
// ─────────────────────────────────────────────────────────────
function newBoss(x, y) {
  return {
    type: 'boss',
    x, y, w: 24, h: 28,
    vx: 0, vy: 0,
    hp: 12, maxHp: 12,
    dir: -1,
    onGround: false,
    frame:      0,
    hurtTimer:  0,
    dead: false,
    phase:      1,
    shootTimer: 110,
    jumpCooldown: 160,
  };
}

function fireBossShot(b, player, projectiles) {
  const bx = b.x + b.w / 2;
  const by = b.y + b.h * 0.35;
  const angle = Math.atan2(
    player.y + player.h / 2 - by,
    player.x + player.w / 2 - bx,
  );
  const count  = b.phase === 2 ? 5 : 3;
  const spread = 0.30;
  const spd    = b.phase === 2 ? 3.0 : 2.5;
  for (let i = 0; i < count; i++) {
    const a = angle + (i - Math.floor(count / 2)) * spread;
    projectiles.push(newProjectile(bx, by, Math.cos(a) * spd, Math.sin(a) * spd, 'enemy', C.boss));
  }
  spawnParticles(bx, by, C.boss, 4,
    { vxRange: 1.5, vyRange: 1.5, vyBias: -0.5, life: 8, size: 1.5 });
}

function updateBoss(b, level, player, projectiles) {
  b.frame++;
  if (b.hurtTimer > 0) b.hurtTimer--;

  // Phase transition
  const newPhase = b.hp <= b.maxHp / 2 ? 2 : 1;
  if (newPhase === 2 && b.phase === 1) {
    b.phase = 2;
    b.shootTimer = Math.min(b.shootTimer, 35);
    spawnParticles(b.x + b.w / 2, b.y + b.h / 2, C.boss, 18,
      { vxRange: 4, vyRange: 4, vyBias: -2.5, life: 35, size: 2.5 });
  }

  const spd = b.phase === 2 ? 1.1 : 0.65;

  // Walk toward player (stop when close)
  const dx = player.x + player.w / 2 - (b.x + b.w / 2);
  if (Math.abs(dx) > 28) {
    b.dir = Math.sign(dx);
    b.vx  = b.dir * spd;
  } else {
    b.vx  = b.vx * 0.85; // decelerate
    b.dir = Math.sign(dx) || b.dir;
  }

  moveAndCollide(b, level);

  // Level-edge guard
  if (b.x <= 2 && b.vx < 0)                  { b.vx = 0; b.dir = 1; }
  if (b.x + b.w >= level.pxW - 2 && b.vx > 0) { b.vx = 0; b.dir = -1; }

  // Jump (phase 2 only)
  if (b.phase === 2 && b.onGround) {
    b.jumpCooldown--;
    if (b.jumpCooldown <= 0) {
      b.jumpCooldown = rng.int(120, 200);
      b.vy = -5.5;
      spawnParticles(b.x + b.w / 2, b.y + b.h, C.boss, 6,
        { vxRange: 2, vyRange: 1, vyBias: 0, life: 12, size: 2 });
    }
  }

  // Shoot
  b.shootTimer--;
  if (b.shootTimer <= 0) {
    b.shootTimer = b.phase === 2 ? rng.int(50, 75) : rng.int(85, 120);
    fireBossShot(b, player, projectiles);
  }
}

// ─────────────────────────────────────────────────────────────
// RENDER — BOSS SPRITE
// ─────────────────────────────────────────────────────────────
function drawBoss(b, camX, camY) {
  if (b.dead) return;
  const sx = Math.round(b.x - camX);
  const sy = Math.round(b.y - camY);
  if (sx + b.w < -4 || sx > GW + 4 || sy + b.h < -4 || sy > GH + 4) return;
  if (b.hurtTimer > 0 && Math.floor(b.hurtTimer / 2) % 2 === 1) return;

  const p2    = b.phase === 2;
  const pulse = 0.6 + 0.4 * Math.sin(b.frame * 0.1);
  const mainC = p2 ? C.boss : '#cc0044';
  const dimC  = p2 ? '#4a0018' : '#2e000e';
  const glowC = p2 ? '#ff88cc' : C.boss;

  ctx.save();
  ctx.translate(sx, sy);
  if (b.dir < 0) { ctx.translate(b.w, 0); ctx.scale(-1, 1); }

  ctx.shadowColor = glowC;
  ctx.shadowBlur  = (p2 ? 14 : 8) * pulse;

  // ── Head ──
  ctx.fillStyle = dimC;
  ctx.fillRect(4, 0, 16, 8);
  ctx.fillStyle = mainC;
  ctx.fillRect(4, 0, 16, 2);  // helmet top
  ctx.fillRect(4, 0, 2, 8);   // left face
  ctx.fillRect(18, 0, 2, 8);  // right face
  // Eyes
  ctx.fillStyle   = p2 ? '#ffccee' : '#ff3333';
  ctx.shadowColor = p2 ? '#ffaadd' : '#ff0000';
  ctx.shadowBlur  = 8 * pulse;
  ctx.fillRect(7, 3, 4, 4);   // left eye
  ctx.fillRect(13, 3, 4, 4);  // right eye

  // ── Shoulder pads ──
  ctx.fillStyle   = mainC;
  ctx.shadowColor = glowC;
  ctx.shadowBlur  = 6;
  ctx.fillRect(0, 6, 5, 8);   // left
  ctx.fillRect(19, 6, 5, 8);  // right

  // ── Torso ──
  ctx.fillStyle = dimC;
  ctx.fillRect(3, 8, 18, 13);
  ctx.fillStyle = mainC;
  ctx.fillRect(3, 8, 3, 12);   // left stripe
  ctx.fillRect(18, 8, 3, 12);  // right stripe
  ctx.fillRect(3, 8, 18, 2);   // chest bar

  // Energy core
  ctx.fillStyle   = p2 ? '#ffffff' : mainC;
  ctx.shadowColor = p2 ? '#ffffff' : glowC;
  ctx.shadowBlur  = 12 * pulse;
  ctx.fillRect(8, 12, 8, 4);

  // ── Belt ──
  ctx.fillStyle   = mainC;
  ctx.shadowColor = glowC;
  ctx.shadowBlur  = 4;
  ctx.fillRect(3, 21, 18, 3);

  // ── Legs ──
  ctx.fillStyle = dimC;
  ctx.fillRect(3, 24, 8, 4);
  ctx.fillRect(13, 24, 8, 4);
  ctx.fillStyle = mainC;
  ctx.fillRect(3, 27, 8, 1);   // left boot
  ctx.fillRect(13, 27, 8, 1);  // right boot

  ctx.restore();
}

// ─────────────────────────────────────────────────────────────
// RENDER — ENEMIES
// ─────────────────────────────────────────────────────────────
function drawEnemy(e, camX, camY) {
  if (e.dead) return;
  const sx = Math.round(e.x - camX);
  const sy = Math.round(e.y - camY);
  // Cull off-screen
  if (sx + e.w < -4 || sx > GW + 4 || sy + e.h < -4 || sy > GH + 4) return;

  // Hurt flash
  if (e.hurtTimer > 0 && Math.floor(e.hurtTimer / 2) % 2 === 1) return;

  ctx.save();
  ctx.translate(sx, sy);
  if (e.dir < 0) { ctx.translate(e.w, 0); ctx.scale(-1, 1); }

  if (e.type === 'walker') {
    ctx.shadowColor = C.enemy;
    ctx.shadowBlur  = 6;
    // Body
    ctx.fillStyle = C.enemyDim;
    ctx.fillRect(0, 1, 10, 8);
    // Armor stripes
    ctx.fillStyle = C.enemy;
    ctx.fillRect(0, 1, 2, 7);   // left
    ctx.fillRect(8, 1, 2, 7);   // right
    ctx.fillRect(0, 1, 10, 2);  // top
    // Eyes
    ctx.shadowColor = '#ffff00';
    ctx.shadowBlur  = 4;
    ctx.fillStyle   = '#ffee00';
    ctx.fillRect(2, 3, 2, 2);
    ctx.fillRect(6, 3, 2, 2);
    // Animated legs
    ctx.shadowColor = C.enemy;
    ctx.shadowBlur  = 4;
    ctx.fillStyle   = C.enemy;
    const leg = Math.sin(e.frame * 0.3) * 2;
    ctx.fillRect(1, 9, 3, 1 + Math.max(0,  leg));
    ctx.fillRect(6, 9, 3, 1 + Math.max(0, -leg));

  } else if (e.type === 'shooter') {
    ctx.shadowColor = '#ff7700';
    ctx.shadowBlur  = 7;
    // Body
    ctx.fillStyle = '#5c1800';
    ctx.fillRect(0, 0, 12, 11);
    ctx.fillStyle = '#ff7700';
    ctx.fillRect(0, 0, 2, 10);
    ctx.fillRect(10, 0, 2, 10);
    ctx.fillRect(0, 0, 12, 2);
    // Eye (pulsing)
    const ePulse = 0.6 + 0.4 * Math.sin(e.frame * 0.15);
    ctx.shadowColor = '#ff2200';
    ctx.shadowBlur  = 6 * ePulse;
    ctx.fillStyle   = `rgb(255,${Math.floor(50 + 40 * ePulse)},0)`;
    ctx.fillRect(4, 3, 4, 4);
    // Cannon
    ctx.shadowColor = '#ff7700';
    ctx.shadowBlur  = 5;
    ctx.fillStyle   = '#994400';
    ctx.fillRect(10, 5, 5, 3);
    ctx.fillStyle   = '#ff7700';
    ctx.fillRect(14, 5, 2, 3);

  } else if (e.type === 'jumper') {
    // Bob when on ground
    const bob = e.onGround ? Math.sin(e.frame * 0.12) * 1.5 : 0;
    ctx.translate(0, bob);
    ctx.shadowColor = '#cc00ff';
    ctx.shadowBlur  = 8;
    // Body
    ctx.fillStyle = '#3a0050';
    ctx.fillRect(1, 1, 8, 8);
    ctx.fillStyle = '#cc00ff';
    ctx.fillRect(1, 1, 2, 7);
    ctx.fillRect(7, 1, 2, 7);
    ctx.fillRect(1, 1, 8, 2);
    ctx.fillRect(1, 7, 8, 2);
    // Eyes
    ctx.shadowColor = '#ffffff';
    ctx.shadowBlur  = 5;
    ctx.fillStyle   = '#ffffff';
    ctx.fillRect(2, 3, 2, 2);
    ctx.fillRect(6, 3, 2, 2);
    // Antennae
    ctx.shadowColor = '#cc00ff';
    ctx.shadowBlur  = 4;
    ctx.fillStyle   = '#cc00ff';
    ctx.fillRect(3, 0, 1, 2);
    ctx.fillRect(6, 0, 1, 2);
  }

  ctx.restore();

  // HP bar above head (only when not at full HP)
  if (e.hp < e.maxHp) {
    fillRect(sx, sy - 4, e.w, 2, '#300');
    fillRect(sx, sy - 4, Math.ceil(e.w * e.hp / e.maxHp), 2, '#f33');
  }
}

// ─────────────────────────────────────────────────────────────
// CAMERA
// ─────────────────────────────────────────────────────────────
function newCamera() { return { x: 0, y: 0 }; }

function updateCamera(cam, target, level) {
  const tx = clamp(target.x + target.w / 2 - GW / 2, 0, level.pxW - GW);
  const ty = clamp(target.y + target.h / 2 - GH / 2, 0, level.pxH - GH);
  cam.x = lerp(cam.x, tx, 0.1);
  cam.y = lerp(cam.y, ty, 0.1);
}

// ─────────────────────────────────────────────────────────────
// RENDER — LEVEL
// ─────────────────────────────────────────────────────────────
function drawBackground(camX, camY) {
  // Fill
  fillRect(0, 0, GW, GH, C.bg);

  // Parallax grid (moves at 0.25x camera speed)
  const gx = (camX * 0.25) % 16;
  const gy = (camY * 0.25) % 16;
  ctx.save();
  ctx.strokeStyle = C.dim;
  ctx.lineWidth   = 0.4;
  for (let x = -gx; x <= GW + 16; x += 16) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GH); ctx.stroke();
  }
  for (let y = -gy; y <= GH + 16; y += 16) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GW, y); ctx.stroke();
  }
  ctx.restore();
}

function drawTile(sx, sy, type) {
  if (type === 1) {  // solid
    fillRect(sx, sy, TS, TS, C.tile);
    fillRect(sx, sy, TS, 1, C.tileHi);       // top highlight
    fillRect(sx, sy, 1, TS, C.tileHi);       // left highlight
    fillRect(sx + TS - 1, sy, 1, TS, C.tileLo); // right shadow
    fillRect(sx, sy + TS - 1, TS, 1, C.tileLo); // bottom shadow
    fillRect(sx + 2, sy + 2, TS - 4, TS - 4, C.tileInner); // inner recess
  } else if (type === 2) {  // one-way platform
    fillRect(sx, sy, TS, 3, C.platform);
    fillRect(sx + 1, sy, TS - 2, 1, C.platEdge);
  } else if (type === 3) {  // spike
    ctx.save();
    ctx.fillStyle   = C.spike;
    ctx.shadowColor = C.spikeGlow;
    ctx.shadowBlur  = 5;
    // Three triangular spikes across the tile
    for (let i = 0; i < 3; i++) {
      const bx = sx + 1 + i * 5;
      ctx.beginPath();
      ctx.moveTo(bx,     sy + TS);
      ctx.lineTo(bx + 3, sy + 5);
      ctx.lineTo(bx + 5, sy + TS);
      ctx.fill();
    }
    ctx.restore();
  }
}

function drawLevel(level, camX, camY) {
  const c0 = Math.max(0, Math.floor(camX / TS) - 1);
  const c1 = Math.min(level.tileW - 1, Math.ceil((camX + GW) / TS) + 1);
  const r0 = Math.max(0, Math.floor(camY / TS) - 1);
  const r1 = Math.min(level.tileH - 1, Math.ceil((camY + GH) / TS) + 1);

  for (let r = r0; r <= r1; r++) {
    for (let c = c0; c <= c1; c++) {
      const t = level.getTile(c, r);
      if (t === 0) continue;
      drawTile(c * TS - camX, r * TS - camY, t);
    }
  }
}

// Coin spark animation
function drawCoins(level, camX, camY, frame) {
  for (const coin of level.coins) {
    if (coin.taken) continue;
    const sx = coin.x - camX;
    const sy = coin.y - camY;
    if (sx < -8 || sx > GW + 8 || sy < -8 || sy > GH + 8) continue;
    const pulse = 0.65 + 0.35 * Math.sin(frame * 0.1 + coin.x * 0.05);
    const r     = 3.5 * pulse;
    ctx.save();
    ctx.shadowColor = C.coinGlow;
    ctx.shadowBlur  = 7;
    ctx.fillStyle   = C.coin;
    ctx.beginPath();
    ctx.arc(sx, sy, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// Exit portal
function drawExit(level, camX, camY, frame) {
  const sx = level.exitX - camX - 8;
  const sy = level.exitY - camY - 8;
  if (sx < -24 || sx > GW + 24) return;
  const pulse = 0.5 + 0.5 * Math.sin(frame * 0.08);

  if (!level.exitOpen) {
    // Locked — dark and dim
    ctx.save();
    ctx.strokeStyle = '#1a2a60';
    ctx.lineWidth   = 1;
    ctx.beginPath(); ctx.arc(sx + 8, sy + 8, 8, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();
    return;
  }

  ctx.save();
  ctx.shadowColor = C.exitGlow;
  ctx.shadowBlur  = 12 + pulse * 10;

  ctx.strokeStyle = C.exit;
  ctx.lineWidth   = 1.5;
  ctx.beginPath(); ctx.arc(sx + 8, sy + 8, 8 + pulse * 2.5, 0, Math.PI * 2); ctx.stroke();

  ctx.fillStyle   = `rgba(0,255,200,${0.12 + pulse * 0.08})`;
  ctx.beginPath(); ctx.arc(sx + 8, sy + 8, 7, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
  if (Math.floor(frame / 22) % 2 === 0) {
    text('EXIT', sx, sy + 21, { size: 4, color: C.exit, glow: C.exitGlow, blur: 3 });
  }
}

// ─────────────────────────────────────────────────────────────
// RENDER — PLAYER SPRITE
// ─────────────────────────────────────────────────────────────
function drawPlayer(p, camX, camY) {
  const sx = Math.round(p.x - camX);
  const sy = Math.round(p.y - camY);

  // Dash trail
  if (p.dashTimer > 0) {
    for (let i = 1; i <= 3; i++) {
      const trailX = sx - p.dir * i * 4;
      ctx.save();
      ctx.globalAlpha = 0.18 - i * 0.04;
      ctx.shadowColor = C.visor;
      ctx.shadowBlur  = 4;
      ctx.fillStyle   = C.visor;
      ctx.fillRect(trailX, sy + 2, p.w, p.h - 4);
      ctx.restore();
    }
  }

  ctx.save();
  ctx.translate(sx, sy);
  if (p.dir < 0) { ctx.translate(p.w, 0); ctx.scale(-1, 1); }

  // Hurt flash
  if (p.hurtTimer > 0 && Math.floor(p.hurtTimer / 3) % 2 === 1) {
    ctx.globalAlpha = 0.25;
  }

  ctx.shadowColor = C.player;
  ctx.shadowBlur  = 8;

  // Body
  ctx.fillStyle = C.playerBody;
  ctx.fillRect(1, 4, PW - 2, PH - 4);

  // Armor stripes
  ctx.fillStyle = C.player;
  ctx.fillRect(1, 4, 2, PH - 7);     // left vertical stripe
  ctx.fillRect(PW - 3, 4, 2, PH - 7); // right vertical stripe
  ctx.fillRect(2, 4, PW - 4, 2);      // top horizontal stripe

  // Belt
  ctx.fillStyle = C.playerDim;
  ctx.fillRect(1, PH - 5, PW - 2, 2);

  // Head
  ctx.fillStyle = C.playerBody;
  ctx.fillRect(2, 0, PW - 4, 5);
  ctx.fillStyle = C.player;
  ctx.fillRect(2, 0, PW - 4, 1);     // helmet top
  ctx.fillRect(2, 0, 1, 5);          // left side
  ctx.fillRect(PW - 3, 0, 1, 5);     // right side

  // Visor
  ctx.shadowColor = C.visor;
  ctx.shadowBlur  = 6;
  ctx.fillStyle   = C.visor;
  ctx.fillRect(4, 1, 3, 2);

  // Legs (animate when running)
  ctx.shadowColor = C.player;
  ctx.shadowBlur  = 5;
  ctx.fillStyle   = C.player;
  if (p.state === 'run') {
    const leg = Math.sin(p.frame * 0.35) * 2.5;
    ctx.fillRect(1,      PH - 4, 3, 3 + Math.max(0,  leg));
    ctx.fillRect(PW - 4, PH - 4, 3, 3 + Math.max(0, -leg));
  } else if (p.state === 'jump' || p.state === 'fall') {
    ctx.fillRect(1,      PH - 4, 3, 2);
    ctx.fillRect(PW - 4, PH - 4, 3, 2);
  } else {
    ctx.fillRect(1,      PH - 4, 3, 3);
    ctx.fillRect(PW - 4, PH - 4, 3, 3);
  }

  // ── Gun (always visible) ──
  const firing  = p.state === 'attack';
  const recoil  = (firing && p.atkTimer > ATK_FRAMES - 3) ? 2 : 0;
  const gripX   = PW - 3 - recoil;
  const barrelX = PW + 1 - recoil;

  // Grip
  ctx.shadowColor = '#446688';
  ctx.shadowBlur  = 3;
  ctx.fillStyle   = '#1e2d44';
  ctx.fillRect(gripX, 5, 5, 5);
  // Barrel
  ctx.fillStyle = '#3a5878';
  ctx.fillRect(barrelX, 6, 8, 2);
  // Barrel highlight stripe
  ctx.fillStyle = '#6a9ab8';
  ctx.fillRect(barrelX, 6, 8, 1);
  // Barrel tip ring
  ctx.fillStyle = '#88bbdd';
  ctx.fillRect(barrelX + 7, 5, 2, 4);

  // Muzzle flash — only on the actual fire frame
  if (firing && p.atkTimer === ATK_FRAMES) {
    ctx.save();
    ctx.shadowColor = '#ffffff';
    ctx.shadowBlur  = 14;
    ctx.fillStyle   = '#ffee44';
    ctx.fillRect(barrelX + 8, 4, 5, 6);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(barrelX + 9, 5, 3, 4);
    ctx.restore();
  }

  ctx.restore();
}

// ─────────────────────────────────────────────────────────────
// RENDER — HUD
// ─────────────────────────────────────────────────────────────
function drawHUD(p, floorNum, isBoss, dashCooldown) {
  // HP
  text('HP', 6, 7, { size: 5, color: C.textDim });
  for (let i = 0; i < p.maxHp; i++) {
    const filled = i < p.hp;
    ctx.fillStyle   = filled ? '#ff3355' : '#0a0020';
    ctx.shadowColor = filled ? '#ff0033' : 'transparent';
    ctx.shadowBlur  = filled ? 5 : 0;
    ctx.fillRect(22 + i * 11, 7, 9, 8);
  }
  ctx.shadowBlur = 0;

  // Coins
  ctx.save();
  ctx.shadowColor = C.coinGlow;
  ctx.shadowBlur  = 5;
  ctx.fillStyle   = C.coin;
  ctx.beginPath(); ctx.arc(8, 24, 3, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
  text(`${p.coins}`, 14, 20, { size: 5, color: C.coin, glow: C.coinGlow, blur: 3 });

  // Floor
  text(`FLOOR ${floorNum}${isBoss ? ' [BOSS]' : ''}`, GW / 2, 7,
    { size: 5, align: 'center', color: C.textDim });

  // Powerup icons (top-right)
  if (p.powerups.length > 0) {
    const PCOLS = { double_jump: C.visor, blade_storm: C.powerup,
                    iron_skin: '#aaaaee', speed_demon: '#ffee00', phase_dash: '#cc44ff', lifesteal: '#ff4466' };
    text('PWR', GW - 6, 7, { size: 4, align: 'right', color: C.textDim });
    p.powerups.forEach((k, i) => {
      const col = PCOLS[k] || '#fff';
      ctx.fillStyle   = col;
      ctx.shadowColor = col;
      ctx.shadowBlur  = 4;
      ctx.fillRect(GW - 9 - i * 10, 14, 8, 8);
    });
    ctx.shadowBlur = 0;
  }

  // Dash cooldown bar (bottom-left)
  if (dashCooldown > 0) {
    const pct = 1 - dashCooldown / DASH_COOLDOWN;
    text('DASH', 6, GH - 18, { size: 3, color: C.textDim });
    fillRect(6, GH - 13, 32, 4, '#111');
    fillRect(6, GH - 13, 32 * pct, 4, C.visor);
  }

  // Boss HP bar (bottom-center, boss floors only)
  if (isBoss && level) {
    const b = level.boss;
    if (b && !b.dead) {
      const bw = 130;
      const bx = (GW - bw) / 2;
      const by = GH - 14;
      const p2 = b.hp <= b.maxHp / 2;
      const hpColor = p2 ? '#ff88cc' : C.boss;
      ctx.save();
      ctx.shadowColor = hpColor;
      ctx.shadowBlur  = 6;
      text('THE  WARDEN', GW / 2, by - 9, { size: 4, align: 'center', color: hpColor });
      ctx.restore();
      fillRect(bx - 1, by - 1, bw + 2, 7, '#0a0020');
      fillRect(bx, by, bw, 5, '#300015');
      fillRect(bx, by, Math.ceil(bw * b.hp / b.maxHp), 5, hpColor);
      if (p2) text('PHASE 2', GW / 2, by + 7, { size: 3, align: 'center', color: '#ff88cc' });
    }
  }
}

// ─────────────────────────────────────────────────────────────
// RENDER — TITLE SCREEN
// ─────────────────────────────────────────────────────────────
function drawTitle(f) {
  fillRect(0, 0, GW, GH, C.bg);

  // Animated grid
  ctx.save();
  ctx.strokeStyle = C.dim;
  ctx.lineWidth   = 0.5;
  const gOff = (f * 0.25) % 16;
  for (let x = -gOff; x < GW + 16; x += 16) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GH); ctx.stroke();
  }
  for (let y = 0; y < GH; y += 16) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GW, y); ctx.stroke();
  }
  ctx.restore();

  // Scan artifact
  const scanY = (f * 0.4) % GH;
  ctx.save();
  ctx.fillStyle = 'rgba(57,255,20,0.04)';
  ctx.fillRect(0, scanY, GW, 3);
  ctx.restore();

  const pulse = 0.75 + 0.25 * Math.sin(f * 0.05);
  ctx.save();
  ctx.shadowColor = C.player;
  ctx.shadowBlur  = 20 * pulse;
  text('VAULT', GW / 2, 32, { size: 26, align: 'center', color: C.player });
  text('RUN',   GW / 2, 60, { size: 26, align: 'center', color: C.player });
  ctx.restore();

  text('ROGUELITE PLATFORMER', GW / 2, 94,
    { size: 5, align: 'center', color: C.textDim });

  if (Math.floor(f / 28) % 2 === 0) {
    text('[ PRESS ENTER TO START ]', GW / 2, 113,
      { size: 6, align: 'center', color: C.text, glow: C.player, blur: 6 });
  }

  text('ARROWS/WASD  Z=ATTACK  SHIFT=DASH  SPACE=JUMP',
    GW / 2, 131, { size: 4, align: 'center', color: C.textDim });

  const meta = loadMeta();
  text(`COINS: ${meta.coins}`, 8, 8, { size: 5, color: C.coin, glow: C.coinGlow, blur: 4 });
  if (meta.coins >= 15) {
    text('[ S ] SHOP', GW - 8, 8, { size: 5, align: 'right', color: C.textDim });
  }

  text('v0.3', GW / 2, GH - 10, { size: 4, align: 'center', color: C.dim });
}

// ─────────────────────────────────────────────────────────────
// RENDER — POWERUP SELECT
// ─────────────────────────────────────────────────────────────
function drawPowerup() {
  fillRect(0, 0, GW, GH, C.bg);
  ctx.save();
  ctx.strokeStyle = C.dim; ctx.lineWidth = 0.4;
  for (let x = 0; x < GW; x += 16) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,GH); ctx.stroke(); }
  for (let y = 0; y < GH; y += 16) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(GW,y); ctx.stroke(); }
  ctx.restore();

  text('CHOOSE  UPGRADE', GW / 2, 9, { size: 7, align: 'center', color: C.text, glow: C.player, blur: 6 });
  text(`FLOOR ${floorNum - 1} CLEARED`, GW / 2, 20, { size: 4, align: 'center', color: C.textDim });

  const n  = powerupChoices.length;
  const cw = 86, ch = 108;
  const gx = 6;
  const totalW = n * cw + (n - 1) * gx;
  const startX = (GW - totalW) / 2;
  const cy = 34;

  powerupChoices.forEach((key, i) => {
    const pu = POWERUPS[key];
    const x0 = Math.floor(startX + i * (cw + gx));
    const pulse = 0.6 + 0.4 * Math.sin(frame * 0.07 + i * 1.2);

    fillRect(x0, cy, cw, ch, C.uiBg);
    ctx.save();
    ctx.strokeStyle = pu.color;
    ctx.shadowColor = pu.color;
    ctx.shadowBlur  = 5 * pulse;
    ctx.lineWidth   = 1;
    ctx.strokeRect(x0, cy, cw, ch);
    ctx.restore();

    // Key hint
    text(`[ ${i + 1} ]`, x0 + cw / 2, cy + 6, { size: 5, align: 'center', color: C.textDim });
    // Color square
    glowRect(x0 + cw / 2 - 5, cy + 18, 10, 10, pu.color, pu.color, 7);
    // Name (may wrap — two short words)
    text(pu.label, x0 + cw / 2, cy + 36, { size: 5, align: 'center', color: pu.color, glow: pu.color, blur: 3 });
    // Desc (up to 2 lines of 4px)
    const words = pu.desc.split('  ·  ');
    words.forEach((w, wi) => text(w, x0 + cw / 2, cy + 52 + wi * 12, { size: 4, align: 'center', color: C.textDim }));
  });

  text('[ ESC ]  SKIP', GW / 2, GH - 10, { size: 4, align: 'center', color: C.textDim });
}

// ─────────────────────────────────────────────────────────────
// RENDER — GAME OVER / WIN / SHOP
// ─────────────────────────────────────────────────────────────
function drawDead() {
  fillRect(0, 0, GW, GH, C.bg);
  drawParticles(0, 0);
  const pulse = 0.7 + 0.3 * Math.sin(frame * 0.06);
  ctx.save();
  ctx.shadowColor = C.hurt;
  ctx.shadowBlur  = 20 * pulse;
  text('YOU  DIED', GW / 2, 36, { size: 18, align: 'center', color: '#ff2222' });
  ctx.restore();
  text(`REACHED FLOOR ${deathFloor}`, GW / 2, 80, { size: 6, align: 'center', color: C.textDim });
  text(`COINS EARNED: ${deathCoins}`, GW / 2, 95, { size: 5, align: 'center', color: C.coin, glow: C.coinGlow, blur: 3 });
  if (Math.floor(frame / 30) % 2 === 0)
    text('[ ENTER ]  RETURN TO TITLE', GW / 2, 120, { size: 5, align: 'center', color: C.text, glow: C.player, blur: 4 });
}

function drawWin() {
  fillRect(0, 0, GW, GH, C.bg);
  drawParticles(0, 0);
  const pulse = 0.6 + 0.4 * Math.sin(frame * 0.07);
  ctx.save();
  ctx.shadowColor = C.exit;
  ctx.shadowBlur  = 24 * pulse;
  text('VAULT', GW / 2, 26, { size: 22, align: 'center', color: C.exit });
  text('CLEARED', GW / 2, 50, { size: 16, align: 'center', color: C.exit });
  ctx.restore();
  text('THE WARDEN HAS FALLEN', GW / 2, 82, { size: 5, align: 'center', color: C.textDim });
  text(`COINS EARNED: ${meta.coins}`, GW / 2, 96, { size: 5, align: 'center', color: C.coin, glow: C.coinGlow, blur: 3 });
  if (Math.floor(frame / 30) % 2 === 0)
    text('[ ENTER ]  RETURN TO TITLE', GW / 2, 118, { size: 5, align: 'center', color: C.text, glow: C.player, blur: 4 });
}

function drawShop() {
  fillRect(0, 0, GW, GH, C.bg);
  text('UPGRADE  SHOP', GW / 2, 7, { size: 7, align: 'center', color: C.text, glow: C.player, blur: 5 });
  text(`COINS: ${meta.coins}`, GW / 2, 19,
    { size: 5, align: 'center', color: C.coin, glow: C.coinGlow, blur: 3 });

  SHOP_ITEMS.forEach((item, i) => {
    const owned  = meta[item.key] | 0;
    const maxed  = owned >= item.maxOwn;
    const canBuy = !maxed && meta.coins >= item.cost;
    const col    = maxed ? C.textDim : canBuy ? item.color : '#333';
    const y0     = 33 + i * 38;

    fillRect(8, y0, GW - 16, 32, C.uiBg);
    ctx.save();
    ctx.strokeStyle = col;
    ctx.shadowColor = col;
    ctx.shadowBlur  = maxed ? 0 : 4;
    ctx.lineWidth   = 1;
    ctx.strokeRect(8, y0, GW - 16, 32);
    ctx.restore();

    text(`[${i + 1}]  ${item.label}`, 14, y0 + 5, { size: 5, color: col });
    text(item.desc, 14, y0 + 16, { size: 4, color: C.textDim });
    if (maxed) {
      text('OWNED', GW - 14, y0 + 5, { size: 4, align: 'right', color: C.textDim });
    } else {
      text(`${item.cost} ¢`, GW - 14, y0 + 5,
        { size: 4, align: 'right', color: canBuy ? C.coin : '#555' });
    }
  });

  if (shopMsg) text(shopMsg, GW / 2, GH - 22, { size: 5, align: 'center', color: C.text, glow: C.player, blur: 4 });
  text('[ ESC / ENTER ]  BACK', GW / 2, GH - 10, { size: 4, align: 'center', color: C.textDim });
}

// ─────────────────────────────────────────────────────────────
// GAME STATE MACHINE
// ─────────────────────────────────────────────────────────────
let gameState   = 'title';
let frame       = 0;
let meta        = loadMeta();

let level       = null;
let player      = null;
let camera      = null;
let projectiles = [];
let floorNum    = 1;
let isBoss      = false;
let coinsRun    = 0;

// Extra state
let powerupChoices = [];   // current powerup options
let deathFloor     = 1;    // floor reached when dying
let deathCoins     = 0;    // coins earned when dying
let shopMsg        = '';   // feedback text in shop

// ── Helpers ──────────────────────────────────────
function startRun() {
  meta        = loadMeta();
  floorNum    = 1;
  isBoss      = false;
  coinsRun    = 0;
  projectiles = [];
  particles   = [];
  level  = new Level(floorNum, isBoss);
  player = newPlayer(TS * 2, 8 * TS - PH, meta);
  // Apply arsenal-level bladestorm as starting powerup icon
  if ((meta.arsenalLevel | 0) > 0 && !player.powerups.includes('blade_storm'))
    player.powerups.push('blade_storm');
  if ((meta.speedLevel | 0) > 0 && !player.powerups.includes('speed_demon'))
    player.powerups.push('speed_demon');
  camera   = newCamera();
  camera.x = 0;
  camera.y = 0;
  gameState = 'playing';
}

function loadNextLevel() {
  projectiles = [];
  particles   = [];
  level  = new Level(floorNum, isBoss);
  player.x  = TS * 2;
  player.y  = 8 * TS - PH;
  player.vx = 0;
  player.vy = 0;
  camera   = newCamera();
  camera.x = 0;
  camera.y = 0;
  gameState = 'playing';
}

function nextFloor() {
  floorNum++;
  isBoss = (floorNum === 4);   // floor 4 is the boss

  // Offer powerup upgrade between every floor
  const available = POWERUP_KEYS.filter(k => !player.powerups.includes(k));
  powerupChoices  = rng.shuffle([...available]).slice(0, Math.min(3, available.length));

  if (powerupChoices.length === 0) {
    loadNextLevel();
  } else {
    gameState = 'powerup';
  }
}

// ── Update ───────────────────────────────────────
function update() {
  frame++;

  if (gameState === 'title') {
    meta = loadMeta();
    if (just('Enter', 'NumpadEnter')) startRun();
    if (just('KeyS')) { shopMsg = ''; gameState = 'shop'; }

  } else if (gameState === 'powerup') {
    for (let i = 0; i < powerupChoices.length; i++) {
      if (just(`Digit${i + 1}`, `Numpad${i + 1}`)) {
        applyPowerup(player, powerupChoices[i]);
        powerupChoices = [];
        loadNextLevel();
        break;
      }
    }
    if (just('Escape')) { powerupChoices = []; loadNextLevel(); }

  } else if (gameState === 'dead') {
    if (just('Enter', 'NumpadEnter')) gameState = 'title';

  } else if (gameState === 'win') {
    if (just('Enter', 'NumpadEnter')) gameState = 'title';

  } else if (gameState === 'shop') {
    SHOP_ITEMS.forEach((item, i) => {
      if (!just(`Digit${i + 1}`, `Numpad${i + 1}`)) return;
      const owned = meta[item.key] | 0;
      if (owned >= item.maxOwn) { shopMsg = 'ALREADY MAXED'; return; }
      if (meta.coins < item.cost) { shopMsg = 'NOT ENOUGH COINS'; return; }
      meta.coins -= item.cost;
      meta[item.key] = owned + 1;
      saveMeta(meta);
      shopMsg = 'PURCHASED!';
    });
    if (just('Escape', 'Enter', 'NumpadEnter')) { shopMsg = ''; gameState = 'title'; }

  } else if (gameState === 'playing') {
    updatePlayer(player, level, projectiles);

    // ── Update enemies / boss ────────────────────────────────
    for (const e of level.enemies) {
      if (e.type === 'boss') updateBoss(e, level, player, projectiles);
      else                   updateEnemy(e, level, player, projectiles);
    }

    // ── Player projectiles vs enemies ──────────────────────
    for (const proj of projectiles) {
      if (proj.owner !== 'player' || proj.dead) continue;
      for (const e of level.enemies) {
        if (!e.dead && overlaps(proj, e)) {
          proj.dead = true;
          const killed = hurtEnemy(e, 1, player);
          if (killed) level.coins.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, taken: false });
        }
      }
    }

    // ── Enemy contact vs player ─────────────────────────────
    for (const e of level.enemies) {
      if (e.dead) continue;
      if (player.hurtCooldown > 0) break;
      if (!overlaps(player, e)) continue;
      // Regular dash (no phase) grants brief immunity
      if (player.dashTimer > 0 && !player.hasPhaseDash) continue;
      hurtPlayer(player, 1);
    }

    // ── Enemy projectiles vs player ─────────────────────────
    for (const proj of projectiles) {
      if (proj.owner !== 'enemy' || proj.dead) continue;
      if (player.hurtCooldown > 0) continue;
      if (!overlaps(proj, player)) continue;
      // Phase-dash: immune to projectiles while dashing
      if (player.dashTimer > 0 && player.hasPhaseDash) continue;
      proj.dead = true;
      hurtPlayer(player, 1);
    }

    projectiles = updateProjectiles(projectiles, level);
    updateParticles();
    updateCamera(camera, player, level);

    // ── Coin pickup ─────────────────────────────────────────
    for (const coin of level.coins) {
      if (!coin.taken &&
          Math.abs(player.x + player.w / 2 - coin.x) < 14 &&
          Math.abs(player.y + player.h / 2 - coin.y) < 14) {
        coin.taken = true;
        player.coins++;
        coinsRun++;
        // Use world coords (drawParticles subtracts camX/camY)
        spawnParticles(coin.x, coin.y, C.coin, 5,
          { vxRange: 1.5, vyRange: 1.5, vyBias: -1, life: 14, size: 1.5 });
      }
    }

    // ── Exit: open when all enemies cleared ─────────────────
    if (!level.exitOpen && level.enemies.every(e => e.dead)) {
      level.exitOpen = true;
    }

    // ── Exit portal collision ───────────────────────────────
    if (level.exitOpen) {
      const portal = { x: level.exitX - 8, y: level.exitY - 16, w: 20, h: 24 };
      if (overlaps(player, portal)) {
        if (isBoss) {
          // Boss floor cleared → victory
          meta.coins += coinsRun;
          coinsRun = 0;
          saveMeta(meta);
          // Celebration particles
          for (let i = 0; i < 6; i++) {
            spawnParticles(rng.int(40, GW - 40), rng.int(30, GH - 30),
              rng.pick([C.exit, C.coin, C.text, C.boss]), 8,
              { vxRange: 3, vyRange: 3, vyBias: -2.5, life: 40, size: 2 });
          }
          gameState = 'win';
        } else {
          nextFloor();
        }
      }
    }

    // ── Player dead ─────────────────────────────────────────
    if (player.dead) {
      deathFloor = floorNum;
      deathCoins = coinsRun;
      meta.coins += coinsRun;
      coinsRun   = 0;
      saveMeta(meta);
      spawnParticles(player.x + player.w / 2, player.y + player.h / 2,
        C.hurt, 14, { vxRange: 4, vyRange: 4, vyBias: -2, life: 35, size: 2.5 });
      gameState = 'dead';
    }

  }

  clearInput();
}

// ── Render ───────────────────────────────────────
function render() {
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, GW, GH);
  textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);

  if (gameState === 'title') {
    drawTitle(frame);

  } else if (gameState === 'playing') {
    const cx = Math.round(camera.x);
    const cy = Math.round(camera.y);

    drawBackground(cx, cy);
    drawLevel(level, cx, cy);
    drawCoins(level, cx, cy, frame);
    drawExit(level, cx, cy, frame);
    drawParticles(cx, cy);

    // Draw regular enemies + boss
    for (const e of level.enemies) {
      if (e.type === 'boss') drawBoss(e, cx, cy);
      else                   drawEnemy(e, cx, cy);
    }

    // Draw projectiles
    for (const proj of projectiles) {
      ctx.save();
      ctx.shadowColor = proj.color;
      ctx.shadowBlur  = proj.owner === 'enemy' ? 8 : 6;
      ctx.fillStyle   = proj.color;
      ctx.fillRect(proj.x - cx, proj.y - cy, proj.w, proj.h);
      ctx.restore();
    }

    drawPlayer(player, cx, cy);
    drawHUD(player, floorNum, isBoss, player.dashCooldown);

  } else if (gameState === 'powerup') {
    drawPowerup();

  } else if (gameState === 'dead') {
    drawDead();

  } else if (gameState === 'win') {
    drawWin();

  } else if (gameState === 'shop') {
    drawShop();
  }

  // Push game frame to phosphor bloom layer
  phosphorCtx.clearRect(0, 0, GW, GH);
  phosphorCtx.drawImage(gameCanvas, 0, 0);
}

// ─────────────────────────────────────────────────────────────
// GAME LOOP
// ─────────────────────────────────────────────────────────────
function loop() { update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
