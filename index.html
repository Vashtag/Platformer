<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VAULT RUN</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100vw;
    height: 100vh;
  }
  canvas { display: block; image-rendering: pixelated; cursor: none; }
</style>
</head>
<body>
<canvas id="crt"></canvas>
<script>
'use strict';

// ─────────────────────────────────────────────────────────────
// CONSTANTS
// ─────────────────────────────────────────────────────────────
const GW = 320, GH = 180;   // internal game resolution
const TS = 16;               // tile size in pixels

// Phosphor-green palette (CRT monitor feel)
const C = {
  bg:        '#020c02',
  dim:       '#071407',
  tile:      '#0d3b0d',
  tileHi:    '#1a5c1a',
  tileShadow:'#051005',
  platform:  '#1f6b1f',
  platEdge:  '#2d962d',
  player:    '#39ff14',
  playerDim: '#1a7a00',
  enemy:     '#ff4500',
  enemyDim:  '#7a2000',
  boss:      '#ff0066',
  bossDim:   '#7a0033',
  bullet:    '#ffe066',
  coin:      '#ffd700',
  coinGlow:  '#ffaa00',
  powerup:   '#00ffff',
  pwrGlow:   '#00aaaa',
  hurt:      '#ff2222',
  exit:      '#00ffcc',
  exitGlow:  '#00ffcc',
  text:      '#39ff14',
  textDim:   '#1a5c1a',
  textBright:'#ccffcc',
  uiBg:      '#040d04',
  uiBorder:  '#1a4a1a',
  spike:     '#cc4400',
};

// ─────────────────────────────────────────────────────────────
// UTILS
// ─────────────────────────────────────────────────────────────
const rng = {
  _s: Date.now() | 1,
  next() {
    this._s ^= this._s << 13;
    this._s ^= this._s >> 17;
    this._s ^= this._s << 5;
    return (this._s >>> 0) / 4294967296;
  },
  int(lo, hi) { return lo + Math.floor(this.next() * (hi - lo + 1)); },
  pick(a)     { return a[this.int(0, a.length - 1)]; },
  shuffle(a)  {
    const r = [...a];
    for (let i = r.length - 1; i > 0; i--) {
      const j = this.int(0, i);
      [r[i], r[j]] = [r[j], r[i]];
    }
    return r;
  },
};

const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp  = (a, b, t)   => a + (b - a) * t;

function overlaps(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

// ─────────────────────────────────────────────────────────────
// INPUT
// ─────────────────────────────────────────────────────────────
const keys     = {};
const pressed  = {};   // fires once on keydown
const released = {};

window.addEventListener('keydown', e => {
  if (!keys[e.code]) pressed[e.code] = true;
  keys[e.code] = true;
  // Prevent arrow keys and space from scrolling
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))
    e.preventDefault();
});
window.addEventListener('keyup', e => {
  keys[e.code] = false;
  released[e.code] = true;
});

function down(...codes) { return codes.some(c => keys[c]); }
function just(...codes) { return codes.some(c => pressed[c]); }
function clearInput() {
  for (const k in pressed)  delete pressed[k];
  for (const k in released) delete released[k];
}

// ─────────────────────────────────────────────────────────────
// CANVAS SETUP
// ─────────────────────────────────────────────────────────────
const crtCanvas = document.getElementById('crt');
const crtCtx    = crtCanvas.getContext('2d');

// Offscreen game canvas (low-res, all gameplay renders here)
const gameCanvas = document.createElement('canvas');
gameCanvas.width  = GW;
gameCanvas.height = GH;
const ctx = gameCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

let crtScale = 1;

function resizeCRT() {
  crtCanvas.width  = window.innerWidth;
  crtCanvas.height = window.innerHeight;
  crtScale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
  crtCtx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resizeCRT);
resizeCRT();

// ─────────────────────────────────────────────────────────────
// DRAW HELPERS  (all draw to offscreen `ctx` at GW×GH)
// ─────────────────────────────────────────────────────────────
function fillRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
}

function glowRect(x, y, w, h, color, glowColor, blur = 6) {
  ctx.save();
  ctx.shadowColor = glowColor ?? color;
  ctx.shadowBlur  = blur;
  ctx.fillStyle   = color;
  ctx.fillRect(x, y, w, h);
  ctx.restore();
}

function text(str, x, y, {
  size  = 6,
  color = C.text,
  align = 'left',
  glow  = null,
  blur  = 4,
} = {}) {
  ctx.save();
  ctx.font          = `${size}px monospace`;
  ctx.textAlign     = align;
  ctx.textBaseline  = 'top';
  if (glow) { ctx.shadowColor = glow; ctx.shadowBlur = blur; }
  ctx.fillStyle = color;
  ctx.fillText(str, x, y);
  ctx.restore();
}

// ─────────────────────────────────────────────────────────────
// CRT POST-PROCESSING
// ─────────────────────────────────────────────────────────────
let _flickerVal   = 1;
let _flickerTimer = 0;

function applyCRT() {
  const dw = GW * crtScale;
  const dh = GH * crtScale;
  const ox = (crtCanvas.width  - dw) / 2;
  const oy = (crtCanvas.height - dh) / 2;

  // Black bars
  crtCtx.fillStyle = '#000';
  crtCtx.fillRect(0, 0, crtCanvas.width, crtCanvas.height);

  // Subtle screen flicker
  _flickerTimer--;
  if (_flickerTimer <= 0) {
    _flickerTimer = rng.int(50, 300);
    _flickerVal   = 0.94 + rng.next() * 0.06;
  }

  // Upscale game canvas
  crtCtx.save();
  crtCtx.globalAlpha = _flickerVal;
  crtCtx.drawImage(gameCanvas, ox, oy, dw, dh);
  crtCtx.restore();

  // Scanlines
  crtCtx.save();
  for (let y = oy; y < oy + dh; y += crtScale * 2) {
    crtCtx.fillStyle = 'rgba(0,0,0,0.28)';
    crtCtx.fillRect(ox, y, dw, crtScale * 0.9);
  }
  crtCtx.restore();

  // Vignette
  const grad = crtCtx.createRadialGradient(
    crtCanvas.width / 2, crtCanvas.height / 2, dh * 0.25,
    crtCanvas.width / 2, crtCanvas.height / 2, dh * 0.72,
  );
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,8,0,0.72)');
  crtCtx.fillStyle = grad;
  crtCtx.fillRect(0, 0, crtCanvas.width, crtCanvas.height);

  // Chromatic aberration (very subtle red ghost shifted right)
  crtCtx.save();
  crtCtx.globalCompositeOperation = 'screen';
  crtCtx.globalAlpha = 0.05;
  crtCtx.drawImage(gameCanvas, ox + crtScale * 0.6, oy, dw, dh);
  crtCtx.restore();

  // Phosphor edge bloom (green tint at screen perimeter)
  const edgeGrad = crtCtx.createRadialGradient(
    crtCanvas.width / 2, crtCanvas.height / 2, dh * 0.42,
    crtCanvas.width / 2, crtCanvas.height / 2, dh * 0.55,
  );
  edgeGrad.addColorStop(0, 'rgba(0,0,0,0)');
  edgeGrad.addColorStop(1, 'rgba(0,30,0,0.12)');
  crtCtx.fillStyle = edgeGrad;
  crtCtx.fillRect(ox, oy, dw, dh);
}

// ─────────────────────────────────────────────────────────────
// TITLE SCREEN
// ─────────────────────────────────────────────────────────────
function drawTitle(f) {
  // Background: animated grid
  fillRect(0, 0, GW, GH, C.bg);

  ctx.save();
  ctx.strokeStyle = C.dim;
  ctx.lineWidth   = 0.5;
  const gOff = (f * 0.25) % 16;
  for (let x = (-16 + gOff); x < GW + 16; x += 16) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GH); ctx.stroke();
  }
  for (let y = 0; y < GH; y += 16) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GW, y); ctx.stroke();
  }
  ctx.restore();

  // Moving horizontal scan artifact
  const scanY = ((f * 0.4) % GH);
  ctx.save();
  ctx.fillStyle = 'rgba(57,255,20,0.04)';
  ctx.fillRect(0, scanY, GW, 3);
  ctx.restore();

  // Title glow pulse
  const pulse = 0.75 + 0.25 * Math.sin(f * 0.05);
  ctx.save();
  ctx.shadowColor = C.player;
  ctx.shadowBlur  = 20 * pulse;
  text('VAULT', GW / 2, 32, { size: 26, align: 'center', color: C.player });
  text('RUN',   GW / 2, 60, { size: 26, align: 'center', color: C.player });
  ctx.restore();

  text('ROGUELITE PLATFORMER', GW / 2, 93, {
    size: 5, align: 'center', color: C.textDim,
  });

  // Blink prompt
  if (Math.floor(f / 28) % 2 === 0) {
    text('[ PRESS ENTER TO START ]', GW / 2, 112, {
      size: 6, align: 'center', color: C.text, glow: C.player, blur: 6,
    });
  }

  text('ARROW KEYS / WASD  ·  Z=ATTACK  ·  SHIFT=DASH', GW / 2, 130, {
    size: 4, align: 'center', color: C.textDim,
  });

  // Meta coins
  const meta = loadMeta();
  text(`COINS: ${meta.coins}`, 8, 8, { size: 5, color: C.coin, glow: C.coinGlow, blur: 4 });
  if (meta.coins >= 15) {
    text('[ S ] SHOP', GW - 8, 8, { size: 5, align: 'right', color: C.textDim });
  }

  text('v0.1', GW / 2, GH - 10, { size: 4, align: 'center', color: C.dim });
}

// ─────────────────────────────────────────────────────────────
// META PERSISTENCE
// ─────────────────────────────────────────────────────────────
function loadMeta() {
  try {
    const raw = localStorage.getItem('vaultrun_meta');
    if (raw) return JSON.parse(raw);
  } catch (_) {}
  return { coins: 0, armorLevel: 0, speedLevel: 0, arsenalLevel: 0 };
}
function saveMeta(meta) {
  try { localStorage.setItem('vaultrun_meta', JSON.stringify(meta)); } catch (_) {}
}

// ─────────────────────────────────────────────────────────────
// GAME STATE MACHINE  (step 1: just title)
// ─────────────────────────────────────────────────────────────
let state = 'title';
let frame = 0;

function update() {
  frame++;

  if (state === 'title') {
    if (just('Enter', 'NumpadEnter')) {
      // placeholder — gameplay comes in next steps
      state = 'title';
    }
  }

  clearInput();
}

function render() {
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, GW, GH);

  if (state === 'title') drawTitle(frame);

  applyCRT();
}

// ─────────────────────────────────────────────────────────────
// GAME LOOP
// ─────────────────────────────────────────────────────────────
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
